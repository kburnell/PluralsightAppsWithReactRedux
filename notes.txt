Pluralsight - Building Apps with React and Redux

Dev Enviornment:
	- https://github.com/coryhouse/pluralsight-redux-starter
	- https://github.com/coryhouse/react-slingshot
	- React
			v15.0.2 (latest v15.6.1)
	- Redux
			v3.5.2 (latest v3.7.2 )
	- React/Router
			2.4.0 (latest v4.1.2)
	- Babel
			6.* (latest 6.23)
	 		es6 transpilation
	- Babel-polyfill
			some features can't be trasnpiled from es6 -> es5, BIG.  Can pull in only polyfills you need
	- WebPack
			1.13 (latest v3.5.5)
	- Mocha
	- ESLint
	- Express

	- Live Reloading using babel-preset-react-hmre

	- npm scripts (bit.ly/npmvsgulp)


React Component Types:
	- Container (smart)
		* focused on how things work
		* aware of redux
		* get data by subscribing to redux state
		* dispatch redux actions
		* generated by react-redux

	- Presentational (dumb)
		* focused on how things look
		* not aware of redux
		* get data from props
		* invoke callbacks on props
		* written completely by hand


Redux:
	- Action
			* plain object containing a description of an event
			* must have a type property
			* can pass along anything else as long as it is serializable
			* created via convenience functions called: Action Creators
					- typically have the same name as the actions type
			* when actions are dispatched in impacts that data that is the store

	- Store
			* store is created by calling 'createStore'
			* you pass the reducer function to 'createStore'
			* 'createStore' is called in the apps entry point
			* single store per application
			* store can only
					- dispatch an action 'store.dispatch(action)'
					- subscribe to a listener 'store.subscribe(listener)'
					- get its current state 'store.getState()'
					- replace its reducer 'replaceReducer(nextReducer)'
			* can not directly manipulate the data in the store, must be done via an action

	- Immutability
		* the existing state can not be changed directly.  it must be replaced with a new state object that represent the latest changes
		* recommended to use 'Object.assign(target, ...sources)' for creating a copy of an object

			state = {
				name: 'Cory House',
				role: 'author'
			}
			Object.assign({}, state, {role: 'admin'});
				line above is creating a new empty object '{}', mixing that new object together with existing 'state', and changing the 'role' property to 'admin'
				end result is a clone of existing state with role changed to admin

				*** first parameter of Object.assign is always an empty to object
				*** Object.assign is a feature that babel can not transpile at this time so babel-pollyfil is required
		* Immutability means clarity.  you always know where the data is being changed, its always done in the reducers
		* Immutability = Performance.  don't have to check everything single property to see if state has changed, can simply do a reference comparison
		* Immutability = Awesome Sauce.  time-travel debuggin, undo/redo, tur off individual actions, play interactions back (Chrome React DevTools)
		* Optional Libraries
			- react-addons-update
			- immutable.js
		* Enforcing Immutability
			- education & trust
			- redux-immutable-state-invariant: library that displays an error when you try to mutate state (**should only be used during development)
			- immutable.js: library that creates immutable javascript objects

	- Reducers
		* function that takes state and an action and returns new state '(state, action) => state'
		* must be pure functions, produce no side effects
		* reducers should never
			- mutate arguments
			- perform side effects (api calls, routing transitions, etc.)
			- call non-pure functions
		* all reducers are called when an action is dispatched, so all reducers should return untouched state if no matching switch is found for the passed action
		* a reducer should handle it's slice of state
		* "Write independent small reducer functions that are each responsible for updates to a specific slice of state.  We call this pattern 'reducer composition'.
		   A given action could be handled by all, some, or none of them."


react-redux
	- handles connecting React components to Redux
	- consists of 2 core items
		* provider component
			- attaches app to redux store
			- uses react's context to make store available to all container components in the app
		* connect function
			- wraps a component so it's connected to the redux store
			- takes two parameters, both are functions and are optional:
				* mapStateToProps
					- defines what part of the redux store you want to expose on your component
					- when defined component will be subscribed to redux store updates, any time it updates mapStateToProps will be called
					- returns an object, each property on the returned object will be a property on the container component
					- "determines what state is available on your container component via props"
					- because it is being called every time redux store is updated, if you are doing something expensive use a library like Reselect for memoizing
						* memoizing: keeping track of each function call so if it has already been run with same parameters it doesn't have to be run again
				* mapDispatchToProps
					- lets us specify which actions to expose as props
					- receives dispatch as its only parameter
					- returns the callback props that you want to pass down
					- 3 ways to handle:
						* ignore it, use dispatch manually passing action creator
							- this.props.dispatch(loadCourses())
							- lots of repetitive boilerplate code
							- redux concerns in child components
						* manually wrap inside the mapDispatchToProps function
							- return { loadCourses: () => { dispatch(loadCourses()); } };
							- makes it clear what is being exposed but can get redundant with many actions
						* use the bindActionCreators convenience function
							- return { actions: bindActionCreators(actions, dispatch) };
							- handles the redundancy, but isn't as clear






